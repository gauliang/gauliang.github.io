{"pageProps":{"params":{"id":["2020","javascript-closure"]},"post":{"id":["posts","2020","javascript-closure"],"contentHtml":"<div class=\"image-widget\"><img src=\"/posts/2020/javascript-closure.files/cover.jpg\" alt=\"Javascript Closure\"><div class=\"figcaption\">Javascript Closure</div></div>\n<h2 id=\"hash-什么是闭包\">什么是闭包</h2>\n<p><strong>定义</strong> 函数和与其相关的词法环境（lexical environment）一起构成闭包（closure）。</p>\n<p>闭包可以让你从内部函数访问外部函数作用域，在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。它使得我们能够创建有状态的函数。</p>\n<h2 id=\"hash-词法环境\">词法环境</h2>\n<p>在 JavaScript 中，每个运行的函数，代码块 {...} 以及整个脚本，都有一个被称为 词法环境（Lexical Environment）的内部对象。\n词法环境对象由两部分组成：</p>\n<ol>\n<li>环境记录（Environment Record）：一个存储所有局部变量作为其属性（包括一些其他信息，例如 this 的值）的对象。</li>\n<li>对 <strong>外部词法环境</strong> 的引用，与外部代码相关联。</li>\n</ol>\n<p>一个”变量“只是 <strong>环境记录</strong> 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。</p>\n<p>在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。\n当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。\n如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。</p>\n<p>这也就是闭包使得 <strong>”在内部函数中总是可以访问其所在的外部函数中声明的变量和参数“</strong> 的原因。</p>\n<p>在 JavaScript 中，所有函数生来就是闭包（只有一个例外，即 <code>new Function</code> 语法，它的 <code>[[Environment]]</code> 指向全局词法环境）。\n也就是说：函数会自动通过隐藏的 <code>[[Environment]]</code> 属性记住创建它们的位置，所以它们都可以访问外部变量。</p>\n<h2 id=\"hash-闭包应用场景\">闭包应用场景</h2>\n<p>闭包通常用于对象的数据私有化。数据私有化是帮助我们开发接口而不是实现（应用程序开发的详细实现）的重要属性。\n他是帮助我们开发强大软件的重要概念，因为实现细节通常比接口约定更容易被破坏。</p>\n<h2 id=\"hash-闭包使用注意事项\">闭包使用注意事项</h2>\n<ol>\n<li>由于闭包中的变量将不会被垃圾回收机制回收，因此，在使用闭包后，您应该手动删除不必要的局部变量，以免大量占用内存资源。</li>\n<li>闭包能够更改父函数中的变量，如果变量是静态变量或私有变量，则必须小心使用它。</li>\n</ol>\n<h2 id=\"hash-参考\">参考</h2>\n<ul>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://javascript.info/closure\">https://javascript.info/closure</a></li>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://developer.mozilla.org/docs/Web/JavaScript/Closures\">https://developer.mozilla.org/docs/Web/JavaScript/Closures</a></li>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://exploringjs.com/deep-js/ch_environments.html\">https://exploringjs.com/deep-js/ch_environments.html</a></li>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://www.debuggr.io/js-closure-in-depth\">https://www.debuggr.io/js-closure-in-depth</a></li>\n</ul>\n","words":1164,"toc":[{"depth":2,"value":"什么是闭包","id":"hash-什么是闭包"},{"depth":2,"value":"词法环境","id":"hash-词法环境"},{"depth":2,"value":"闭包应用场景","id":"hash-闭包应用场景"},{"depth":2,"value":"闭包使用注意事项","id":"hash-闭包使用注意事项"},{"depth":2,"value":"参考","id":"hash-参考"}],"title":"Javascript Closure","date":"2020-10-11T10:45:55.000Z","draft":false,"description":"函数和与其相关的词法环境（lexical environment）一起构成闭包（closure）。闭包可以让你从内部函数访问外部函数作用域，在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。","type":"posts","tags":["closure","lexical-environment","javascript","node.js","闭包"],"series":false,"author":"Gl","cover":"cover.jpg"},"prev":{"title":"Block Formatting Context","date":1602320609000,"draft":false,"description":"块格式化上下文(Block Formatting Context) 是一个独立的渲染区域，它指定内部 `Block-level Box` 的布局方式，并且与该区域的外部无关（无论内部元素如何排列，都不会影响外部元素）。","type":"posts","tags":["BFC","CSS","layout"],"series":false,"author":"Gl","cover":false,"path":"/blogs/2020/block-formatting-context","slug":"2020/block-formatting-context"},"next":{"title":"深入 Flexbox Layout","date":1603613180000,"draft":false,"description":"在 CSS3 中加入了 Flex 布局能力，使得实现弹性布局变得轻而易举，本文将全面深入介绍 flex 在的布局中的使用。","type":"posts","tags":["css","flex","layout"],"series":false,"author":"Gl","cover":"cover.jpg","path":"/blogs/2020/flex-layout","slug":"2020/flex-layout"}},"__N_SSG":true}