{"pageProps":{"params":{"id":["2020","dive-into-webpack"]},"post":{"id":["posts","2020","dive-into-webpack"],"contentHtml":"<div class=\"image-widget\"><img src=\"/attachments/posts/2020/dive-into-webpack.files/webpack.jpg\" alt=\"webpack\"><div class=\"figcaption\">webpack</div></div>\n<p>前端生态蓬勃发展，各垂直领域都有众多设计精良的优秀项目，几乎在所有场景中，应用系统都不同程度依赖这些三方项目。\n同时，新的设计理念不断被提出并投入实践，应用程序本身也变的复杂起来。这为快速构建和部署项目带来了挑\n战，于是，很多用于工程化管理前端项目的工具诞生了，Webpack 正是这样一个工具。</p>\n<p>接下来，我们将深入探索 webpack ，本文假设你对 webpack 已有初步了解。</p>\n<h2 id=\"hash-Webpack-是什么\">Webpack 是什么</h2>\n<p>从代码管理角度讲，webpack 是一个静态模块打包器，他将模块间的依赖关系换转成一个 chunk 图，此依赖图对应映射到\n项目所需的每个模块，并生成一个或多个 bundle。</p>\n<p>从应用程序角度讲，大多数情况下，网站不再只是用带有一些可选 JavaScript 的纯 HTML 编写，它们通常完全由 JavaScript\n构建。因此，我们必须将代码打包，最小化和翻译成所有浏览器都能理解的东西，这就是webpack的用武之地。</p>\n<p>webpack 还提供了一个开发服务器，可以在保存时即时更新模块和样式。<code>vue create</code> 并 <code>create-react-app</code> 依赖于后台的\nwebpack，但是您可以轻松地为他们设置自己的 webpack 配置。</p>\n<h2 id=\"hash-Entry-Output\">Entry &#x26; Output</h2>\n<p>Entry &#x26; Output 是 webpack 的基本配置，指定程序入口点和输出信息。</p>\n<ol>\n<li><strong>entry</strong> 指定构建依赖图时的入口点，webpack 会从该点其，一次找出模块间的依赖关系。<br>\n默认值是 <code>./src/index.js</code>。</li>\n<li><strong>output</strong> 告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。<br>\n默认值是 <code>./dist/main.js</code>。</li>\n</ol>\n<p>配置 <code>webpack.config.js</code> 可改变上述默认行为：</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span><span class=\"token property-access\">exports</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">entry</span><span class=\"token operator\">:</span> <span class=\"token string\">'./path/to/my/entry/file.js'</span>\n  <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> __dirname <span class=\"token operator\">+</span> <span class=\"token string\">'dist'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'my-first-webpack.bundle.js'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h3 id=\"hash-Chunk\">Chunk</h3>\n<p>打包过程中，模块会被合并成 chunk。 chunk 合并成 chunk 组，并形成一个通过模块互相连接的图(ModuleGraph)。chunk 有两种形式：</p>\n<ul>\n<li>initial(初始化) 是入口起点的 main chunk。此 chunk 包含为入口起点指定的所有模块及其依赖项。</li>\n<li>non-initial 是可以延迟加载的块。可能会出现在使用 动态导入(dynamic imports) 或者 SplitChunksPlugin 时。</li>\n</ul>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// main.js</span>\n<span class=\"token keyword module\">import</span> <span class=\"token imports\"><span class=\"token maybe-class-name\">React</span></span> <span class=\"token keyword module\">from</span> <span class=\"token string\">\"react\"</span>\n<span class=\"token keyword module\">import</span> <span class=\"token imports\"><span class=\"token maybe-class-name\">ReactDOM</span></span> <span class=\"token keyword module\">from</span> <span class=\"token string\">\"react-dom\"</span>\n\n<span class=\"token keyword module\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token maybe-class-name\">App</span></span><span class=\"token arrow operator\">=></span><span class=\"token punctuation\">{</span>\n    <span class=\"token maybe-class-name\">ReactDOM</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&#x3C;</span><span class=\"token maybe-class-name\">App</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"root\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<div class=\"remark-highlight\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># output</span>\n/dist/main.js   - initial chunk       包含 react,react-dom,main.js\n/dist/375.js    - non-initial chunk   包含 app.jsx\n</code></pre></div>\n<h4 id=\"hash-Output\">Output</h4>\n<p>输出文件的名称会受配置中的两个字段的影响：</p>\n<ol>\n<li><code>output.filename</code> - 用于 initial chunk 文件</li>\n<li><code>output.chunkFilename</code> - 用于 non-initial chunk 文件</li>\n<li>在某些情况下，使用 initial 和 non-initial 的 chunk 时，可以使用 output.filename。</li>\n</ol>\n<p>这些字段中会有一些 占位符。常用的占位符如下：</p>\n<ol>\n<li><code>[id]</code> - chunk id（例如 [id].js -> 485.js）</li>\n<li><code>[name]</code> - chunk name（例如 [name].js -> app.js）。如果 chunk 没有名称，则会使用其 id 作为名称</li>\n<li><code>[contenthash]</code> - 输出文件内容的 md4-hash（例如 [contenthash].js -> 4ea6ff1de66c537eb9b2.js）</li>\n</ol>\n<h2 id=\"hash-Module\">Module</h2>\n<p>通常，当我们提及模块，一般是指 Javascript 模块。在 webpack 语境下，模块可以是任何东西。下面是一些示例：</p>\n<ol>\n<li>ES2015 import 语句</li>\n<li>CommonJS require() 语句</li>\n<li>AMD define 和 require 语句</li>\n<li>css/sass/less 文件中的 @import 语句。</li>\n<li>stylesheet url(...) 或者 HTML <code>&#x3C;img src=...></code> 文件中的图片链接。</li>\n</ol>\n<p>webpack 原生支持如下模块类型：</p>\n<ol>\n<li>ECMAScript 模块</li>\n<li>CommonJS 模块</li>\n<li>AMD 模块</li>\n<li>Assets</li>\n<li>WebAssembly 模块</li>\n</ol>\n<h2 id=\"hash-Loader\">Loader</h2>\n<p>我们通过 <strong>loader</strong> 使 webpack 处理 <code>js</code> 和 <code>json</code> 之外任何类型的文件（模块），如后缀巍为<strong>ts</strong>、<strong>scss</strong>、<strong>jsx</strong> 和 <strong>vue</strong>。\nloader 向 webpack 描述了如何处理非原生模块，并将相关依赖引入到你的 bundles中。loader 有两个属性：</p>\n<ol>\n<li><code>test</code> 属性，识别出哪些文件会被转换。</li>\n<li><code>use</code> 属性，指出在进行转换时，应该使用哪个 loader。</li>\n</ol>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmodule<span class=\"token punctuation\">.</span><span class=\"token property-access\">exports</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'my-first-webpack.bundle.js'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">module</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">rules</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\"><span class=\"token special-escape escape\">\\.</span>txt<span class=\"token anchor function\">$</span></span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">use</span><span class=\"token operator\">:</span> <span class=\"token string\">'raw-loader'</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<h2 id=\"hash-Plugin\">Plugin</h2>\n<p>webpack 插件是一个具有 apply 方法的 JavaScript 对象。与 loader(仅用于转换某些类型的模块)不同，插件的目的在于扩展 webpack 自身能力，其可以直接访问 compiler 对象，\n通常用于处理 loader 无法完成的其他工作，如打包优化、资源管理。</p>\n<h2 id=\"hash-Mode\">Mode</h2>\n<p>webpack 有两种操作模式：开发(development)和生产(production)。 它们之间的主要区别是生产模式自动生成一些优化后的代码。</p>\n<h2 id=\"hash-Code-Splitting\">Code Splitting</h2>\n<p>代码分离能够把代码分离到不同的 bundle 中，然后按需加载或并行加载这些文件。常用的代码分离方法有三种：</p>\n<ol>\n<li>入口起点：entry 配置</li>\n<li>防止重复：SplitChunksPlugin 配置</li>\n<li>动态导入：通过模块的内联函数调用来分离代码。<code>import()</code> 或 <code>require.ensure()</code>；</li>\n</ol>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span><span class=\"token property-access\">exports</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">mode</span><span class=\"token operator\">:</span> <span class=\"token string\">'development'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 入口起点：entry 配置</span>\n    <span class=\"token literal-property property\">entry</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token string\">'./src/index.js'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">another</span><span class=\"token operator\">:</span> <span class=\"token string\">'./src/another-module.js'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> <span class=\"token string\">'[name].bundle.js'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">resolve</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'dist'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">optimization</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 防止重复：SplitChunksPlugin 配置</span>\n        <span class=\"token literal-property property\">splitChunks</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token literal-property property\">chunks</span><span class=\"token operator\">:</span> <span class=\"token string\">'all'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<h2 id=\"hash-HMR\">HMR</h2>\n<p>模块热替换(HMR - hot module replacement)功能会在应用程序运行过程中，替换、添加或删除 模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：</p>\n<ol>\n<li>保留在完全重新加载页面期间丢失的应用程序状态。</li>\n<li>只更新变更内容，以节省宝贵的开发时间。</li>\n<li>在源代码中 CSS/JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li>\n</ol>\n<p><code>devServer.hot = true</code></p>\n<h2 id=\"hash-Treeshaking\">Treeshaking</h2>\n<p>使 treeshaking 生效需要满足以下条件：</p>\n<ol>\n<li>使用 ESM 规范</li>\n<li>配置 babel-loader 不将 EMS 转为 CMD</li>\n<li>运行在 production 模式</li>\n</ol>\n<p>注：在 webpack v4+ 将会在生产模式下，默认开启代码压缩。</p>\n<h2 id=\"hash-性能优化\">性能优化</h2>\n<p>可以从以下几个角度考虑优化构建性能：</p>\n<ol>\n<li>将 <code>webpack</code>、<code>npm</code>和<code>yarn</code> 更新到最新版本；</li>\n<li>将 loader 应用于最少数量的必要模块；</li>\n<li>每个额外的 loader/plugin 都有其启动时间。尽量少地使用工具；</li>\n<li>优化模块解析条目；</li>\n<li>使用 dll 插件为更改不频繁的代码生成单独的编译结果；</li>\n<li>尽量保持 chunk 体积小；使用数量更少/体积更小的 library；在多页面应用程序中使用 SplitChunksPlugin ，并开启 async 模式；移除未引用代码；只编译你当前正在开发的那些代码。</li>\n<li>worker 池</li>\n<li>持久化缓存</li>\n<li>移除 Progress plugin</li>\n<li>留意自定义 plugin/loader</li>\n<li>增量编译</li>\n<li>在内存中编译</li>\n<li>不同的 devtool 设置，会导致性能差异。</li>\n<li>避免在生产环境下才会用到的工具，某些 utility, plugin 和 loader 都只用于生产环境。</li>\n<li>最小化 entry chunk</li>\n<li>避免额外的优化步骤</li>\n<li>输出结果不携带路径信息</li>\n<li>为 TypeScript loader 传入 transpileOnly 选项，以缩短使用 ts-loader 时的构建时间。</li>\n</ol>\n<h2 id=\"hash-参考\">参考</h2>\n<ol>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://peerigon.github.io/talks/2018-09-28-hackerkiste-webpack-deep-dive\">https://peerigon.github.io/talks/2018-09-28-hackerkiste-webpack-deep-dive</a></li>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://www.taniarascia.com/how-to-use-webpack/\">https://www.taniarascia.com/how-to-use-webpack/</a></li>\n</ol>\n","words":3949,"toc":[{"depth":2,"value":"Webpack 是什么","id":"hash-Webpack-是什么"},{"depth":2,"value":"Entry & Output","id":"hash-Entry-Output"},{"depth":2,"value":"Module","id":"hash-Module"},{"depth":2,"value":"Loader","id":"hash-Loader"},{"depth":2,"value":"Plugin","id":"hash-Plugin"},{"depth":2,"value":"Mode","id":"hash-Mode"},{"depth":2,"value":"Code Splitting","id":"hash-Code-Splitting"},{"depth":2,"value":"HMR","id":"hash-HMR"},{"depth":2,"value":"Treeshaking","id":"hash-Treeshaking"},{"depth":2,"value":"性能优化","id":"hash-性能优化"},{"depth":2,"value":"参考","id":"hash-参考"}],"title":"深入 Webpack","date":"2020-11-05T00:34:50.000Z","draft":false,"description":"大多数情况下，网站不再只是用带有一些可选 JavaScript 的纯 HTML 编写，它们通常完全由 JavaScript 构建。因此，我们必须将代码打包，最小化和翻译成所有浏览器都能理解的东西，这就是webpack的用武之地。","type":"posts","tags":["webpack","devops","node.js","esm"],"series":false,"author":"Gl","cover":"webpack.jpg"},"prev":{"title":"深入 Flexbox Layout","date":1603613180000,"draft":false,"description":"在 CSS3 中加入了 Flex 布局能力，使得实现弹性布局变得轻而易举，本文将全面深入介绍 flex 在的布局中的使用。","type":"posts","tags":["css","flex","layout"],"series":false,"author":"Gl","cover":"cover.jpg","path":"/blogs/2020/flex-layout","slug":"2020/flex-layout"},"next":{"title":"深入 React Redux","date":1605399854000,"draft":false,"description":"React Redux是React的官方Redux UI绑定库 。 如果您同时使用Redux和React，则还应该使用React Redux绑定这两个库。","type":"posts","tags":["react","redux","flux","javascript","node.js","redux-toolkit"],"series":false,"author":"Gl","cover":"dive-react-redux.jpg","path":"/blogs/2020/dive-react-redux","slug":"2020/dive-react-redux"}},"__N_SSG":true}