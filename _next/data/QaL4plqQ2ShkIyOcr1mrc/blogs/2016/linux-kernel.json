{"pageProps":{"id":["posts","2016","linux-kernel"],"post":{"id":["posts","2016","linux-kernel"],"contentHtml":"<p>Linux 内核学习笔记整理。</p>\n<h2 id=\"hash-Unix\">Unix</h2>\n<p>Unix 已有 40 历史，但计算机科学家仍认为其是现存操作系统中最大和最优秀的系统，它已成为一种传奇的存在，历经时间的考验却依然声名不坠。</p>\n<p>1973 年，在用 C 语言重写了 Unix 系统后，大量的 Unix 衍生版本开始出现，许多公司把 Unix 移植到新的机型上，开发者们都按照自己的方式不断增强系统的功能。\nUnix 系统设计简洁并在发布时提供源代码，所以许多团体都对其进行了进一步的开发。加州大学伯克利分校便是其中影响最大的一个。\n在 BSD 基础上，很多厂商也推出了自己的 Unix ,如 SunOS、HP-UX 等。1991 Linux 在 Internet 上发布了它的 Unix。\n从此 Linux 便起航了，Linux 很快吸引了众多开发者、黑客对其代码进行修改和完善，由于其开源性，Linux 迅速成为多人合作的开源项目。</p>\n<h2 id=\"hash-操作系统与内核\">操作系统与内核</h2>\n<p>操作系统包括内核、设备驱动程序、启动引导程序、命令行shell、基本系统工具等部分。内核是操作系统的真正核心，负责硬件设备管理、分配系统资源等任务。\n内核一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限，这种系统态和被保护起来的空间统称为内核空间。\n应用程序在用户空间只能看到允许它们访问的部分系统资源、只能使用某些特定的系统功能，无法直接访问硬件、也不能访问内核划给别人的内存范围，还有一些其他的限制。\n应用程序通过 <strong>系统调用</strong> 与内核通信，让内核代其完成不同的任务。</p>\n<p>内核还负责管理系统的硬件设备。当硬件设备想要和系统通信的时候，它会发出一个异步的中断信号以打断处理器执行，继而打断内核执行。\n中断通常对应着一个中断号，内核通过中断号查找相应的中断服务程序，并调用这个程序响应和处理中断。\n中断服务程序在一个与所有进程都无关的、专门处理中断的上下文中运行，以保证中断服务程序能在第一时间响应和处理中断请求并快速退出。</p>\n<h2 id=\"hash-单内核与微内核\">单内核与微内核</h2>\n<p>操作系统的内核可分为两大阵营：单��核和微内核。单内核就是把它从整体上作为一个大的过程来实现，同时也运行在一个单独的地址空间上，其特点是高性能。\n微内核并不作为一个单独的大过程来实现，其根据功能不同划分成多个独立的 <strong>过程</strong>，其特点是各 <strong>过程</strong> 独立运行，避免了一个模块出现问题后祸及另一个。\n其相比单内核设计多了模块间的通信机制等环节，而单内核却没有这些消息传递的开销。所以，大部分基于微内核的系统都让大部分或全部功能 <strong>过程</strong> 全部运行在内核，\n如此便可以直接调用函数，消除频繁的上下文切换。windowNT、Mach就是微内核的典型实例。Linux 是单内核，但是其汲取了微内核的精华部分。\nLinux是模块化的、多线程的以及内核本身可调度的操作系统。</p>\n<h2 id=\"hash-内核版本号\">内核版本号</h2>\n<p>主版本号.副版本号.修订版本号</p>\n<p>副版本号反映了该内核是一个稳定版本还是一个处于开发中的版本：如果该数字是偶数，那么此版本就是稳定版；如果是奇数，那么他就是开发版。</p>\n<h2 id=\"hash-获取源码\">获取源码</h2>\n<p>官网地址：<a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"http://www.kernel.org\">www.kernel.org</a>\n仓库地址：git.kernel.org</p>\n<h2 id=\"hash-编译内核\">编译内核</h2>\n<p>由于从未配置过内核，所以使用缺省配置编译内核，据说这个默认配置是 Linus 本人的配置。</p>\n<div class=\"remark-highlight\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> defconfig\n</code></pre></div>\n<p>如果要减少编译过程中的输出信息，可以使用下列命令</p>\n<div class=\"remark-highlight\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> <span class=\"token operator\">></span> <span class=\"token punctuation\">..</span> /detritus\n</code></pre></div>\n<p>如此一来，如果你要查看编译信息，可查看该文件。当然你也可以直接 make > /dev/null 把无用信息重定向。</p>\n<h2 id=\"hash-安装内核\">安装内核</h2>\n<div class=\"remark-highlight\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> modules_install\n</code></pre></div>\n<p>上面命令可以把所有已编译的模块安装到正确的主目录。编译时会在内核代码根目录生成一个 system.map 文件，这是一个符号对照表。</p>\n<h2 id=\"hash-内核开发\">内核开发</h2>\n<p>内核开发对性能的要求非常高。内核开发不能访问 C 库，也不能访问标准的 C 头文件。\n内核开发必须使用 GNU C，对内核来说完整的 C 库（甚至是一个子集）太大且太低效了。但大部分常用的 C 库函数在内核中都已经得到了实现。\nLinux 的内核混合使用了 C 语言和汇编语言，在靠近底层或对执行时间要求严格的地方，一般使用的都是汇编语言。GCC 支持使用 asm() 指令在 C 中嵌入汇报代码。</p>\n<p><strong>条件分支优化</strong></p>\n<p>对于条件选择语句，在经常条件经常出现或极少出现的时候，编译前可根据分支声明语句对条件分支进行优化。示例：</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/* 把一个条件标记成极少发生的分支。 */</span>\n<span class=\"token keyword control-flow\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">unlikely</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token spread operator\">...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>这里一定要确保是否当前条件在绝大多数都会成立，如果你判断正确，那么程序性能将得到答复提升，否则，反而会降低性能。</p>\n<p><strong>没有内存保护机制</strong></p>\n<p>如果用户程序试图进行一次非法的内存访问，内核会发现这个错误，并结束这个进程。然而如果内核自己非法访问了内存，那后果就很难控制了，因为没有其他的任何东西可以对内核进行监控。还有一点，内核中的内存都不分页。</p>\n<h2 id=\"hash-扩展\">扩展</h2>\n<p>内核拥有整个系统的最高权限，关于内核开发的特别注意事项还有很多，可以到更专业一点的文章中了解。</p>\n","words":2039,"toc":[{"depth":2,"value":"Unix","id":"hash-Unix"},{"depth":2,"value":"操作系统与内核","id":"hash-操作系统与内核"},{"depth":2,"value":"单内核与微内核","id":"hash-单内核与微内核"},{"depth":2,"value":"内核版本号","id":"hash-内核版本号"},{"depth":2,"value":"获取源码","id":"hash-获取源码"},{"depth":2,"value":"编译内核","id":"hash-编译内核"},{"depth":2,"value":"安装内核","id":"hash-安装内核"},{"depth":2,"value":"内核开发","id":"hash-内核开发"},{"depth":2,"value":"扩展","id":"hash-扩展"}],"title":"Linux 内核概述 - Linux Kernel","author":"高国良","type":"posts","series":false,"date":"2016-08-26T13:15:00.791Z","tags":["linux","Kernel","C"],"description":"Linux 内核学习笔记整理。 Unix unix 已有40历史，但计算机科学家仍认为其是现存操作系统中最大和最优秀的系统，它已成为一种传奇的存在，历经时间的考验却依然声名不坠。 1973 年，在用 C 语言重写了 Unix 系统后，大量的Unix衍生版本开始出现，许多公司把 unix 移植到新的机","draft":false,"cover":false},"prev":{"title":"构建一个基本的前端自动化开发环境 —— 基于 Gulp 的前端集成解决方案（四）","author":"高国良","type":"posts","series":false,"date":1448439900791,"tags":["gulp","sass","npm"],"description":"在对于 npm、node、gulp 有了基本的认识之后，本文主要介绍如何构建一个基本的前端自动化开发环境。下面将逐步构建一个可以自动编译 sass 文件、压缩 javascript 文件、多终端多浏览器同步测试的开发环境，并且还可以通过 piblish 命令对项目下的文件进行打包操作。","draft":false,"cover":false,"path":"/blogs/2015/work-with-gulp+build-a-basic-front-end-automation-development-environment","slug":"2015/work-with-gulp+build-a-basic-front-end-automation-development-environment"},"next":{"title":"Git 子模块 - submodule","author":"高国良","type":"posts","series":false,"date":1475140500791,"tags":["git"],"description":"有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你 独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在 一个项目中使用另一个。","draft":false,"cover":false,"path":"/blogs/2016/git-submodule","slug":"2016/git-submodule"}},"__N_SSG":true}