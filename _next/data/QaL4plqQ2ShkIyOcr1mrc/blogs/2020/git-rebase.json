{"pageProps":{"id":["posts","2020","git-rebase"],"post":{"id":["posts","2020","git-rebase"],"contentHtml":"<div class=\"image-widget\"><img src=\"/attachments/posts/2020/git-rebase.files/cover.jpg\" alt=\"\"></div>\n<p>在 Git 中整合来自不同分支的修改主要有两种方法：<strong>merge</strong> 以及 <strong>rebase</strong>。\n这两种整合方法的最终效果一致，但 rebase 使得提交历史更加整洁。\n在查看一个经过 rebase 的分支历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，\n提交历史是一条直线没有分叉。</p>\n<h2 id=\"hash-执行流程\">执行流程</h2>\n<p>Rebase 背后的执行流程如下：</p>\n<ol>\n<li>找出 <strong>当前分支</strong> 和 <strong>rebase 目标分支</strong> 的最近共同祖先节点；</li>\n<li>对比当前分支相对于该祖先的历次提交，提取相应的修改并存到临时区域；</li>\n<li>定位目标分支最后更新节点；</li>\n<li>将之前另存为临时文件的修改依序应用。</li>\n<li>在目标分支进行 <strong>快进合并</strong></li>\n</ol>\n<p><strong>rebase</strong> 将一系列提交按照原有次序依次应用到另一分支上，这与 <strong>merge</strong> 直接把最终结果合并在一起创建新的提交不同。\n这也意味着，<strong>rebase</strong> 修改了提交历史。</p>\n<h2 id=\"hash-Rebase-进阶\">Rebase 进阶</h2>\n<p>在对两个分支进行 rebase 时，生成的 ”补丁“ 不一定要在目标分支上应用，还可以指定另外一个分支进行应用。</p>\n<div class=\"remark-highlight\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rebase --onto master server client\n</code></pre></div>\n<p>以上命令将取出 client 分支，找出它从 server 分支分岔之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样。</p>\n<p>应用补丁过程中的冲突会阻止 rebase 继续执行，在处理完冲突后直接执行 <code>git rebase --continue</code> 即可，无需 <code>commit</code>。如果要绕过导致合并失败的提交，可以执行\n<code>git rebase --skip</code>。如果要取消 rebase，执行 <code>git rebase --abort</code>。</p>\n<p>考虑以下情况：</p>\n<div class=\"remark-highlight\"><pre class=\"language-text\"><code class=\"language-text\">     A---B---C topic\n    /\nD---E---F---G master</code></pre></div>\n<p>假设你当前处于 <strong>topic</strong> 分支上，执行下面命令，得到结果是相同的：</p>\n<div class=\"remark-highlight\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rebase master\n<span class=\"token function\">git</span> rebase master topic\n</code></pre></div>\n<p>结果</p>\n<div class=\"remark-highlight\"><pre class=\"language-text\"><code class=\"language-text\">              A&#x26;#39;--B&#x26;#39;--C&#x26;#39; topic\n             /\nD---E---F---G master</code></pre></div>\n<h2 id=\"hash-Rebase-风险\">Rebase 风险</h2>\n<p>不要在公共分支上进行 rebase 操作，别人可能基于你的提交进行开发。总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>\n","words":1020,"toc":[{"depth":2,"value":"执行流程","id":"hash-执行流程"},{"depth":2,"value":"Rebase 进阶","id":"hash-Rebase-进阶"},{"depth":2,"value":"Rebase 风险","id":"hash-Rebase-风险"}],"title":"Git Rebase","date":"2020-09-13T01:39:21.000Z","draft":false,"description":"在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。rebase 命令能够将提交到某一分支上的所有修改都应用到另一分支上。","type":"posts","tags":["devops","git","rebase"],"series":false,"author":"GauLiang","cover":"cover.jpg"},"prev":{"title":"ECMAScript Modules","date":1599470041000,"draft":false,"description":"ES6 中首次内置了对模块的支持。从理论上讲，ECMAScript模块应该在所有JavaScript环境中通用。实际上，浏览器仍然是ES模块的主要目标。","type":"posts","tags":["esm","javascript"],"series":false,"author":"GauLiang","cover":false,"path":"/blogs/2020/es-modules","slug":"2020/es-modules"},"next":{"title":"Javascript Promise","date":1599998424000,"draft":false,"description":"Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。","type":"posts","tags":["javascript","node.js","promise"],"series":false,"author":"GauLiang","cover":"001.jpg","path":"/blogs/2020/promise","slug":"2020/promise"}},"__N_SSG":true}