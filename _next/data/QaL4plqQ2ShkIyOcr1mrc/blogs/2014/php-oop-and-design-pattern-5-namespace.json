{"pageProps":{"id":["posts","2014","php-oop-and-design-pattern-5-namespace"],"post":{"id":["posts","2014","php-oop-and-design-pattern-5-namespace"],"contentHtml":"<p>PHP高级程序设计 学习笔记 2014.06.12</p>\n<h2 id=\"hash-命名空间概述\">命名空间概述</h2>\n<p>PHP 在 5.3.0 以后的版本开始支持命名空间。什么是命名空间？\n从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。\n在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题：</p>\n<ol>\n<li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</li>\n<li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li>\n</ol>\n<p>PHP 命名空间提供了一种将相关的类、函数和常量组合到一起的途径。下面是一个说明 PHP 命名空间语法的示例：</p>\n<h2 id=\"hash-定义命名空间\">定义命名空间</h2>\n<p>虽然任意合法的PHP代码都可以包含在命名空间中，但只有三种类型的代码受命名空间的影响，它们是：类，函数和常量。命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间。另外，与PHP其它的语言特征不同，同一个命名空间可以定义在多个文件中，即允许将同一个命名空间的内容分割存放在不同的文件中。当然你也可以在同一个文件中定义多个命名空间。</p>\n<div class=\"remark-highlight\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token keyword\">namespace</span> <span class=\"token package\">MyProject</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name-definition class-name\">MyClass</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">#code...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p><strong>定义子命名空间：</strong> 与目录和文件的关系很象，PHP 命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名字可以使用分层次的方式定义：</p>\n<div class=\"remark-highlight\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token keyword\">namespace</span> <span class=\"token package\">MyProject<span class=\"token punctuation\">\\</span>helper<span class=\"token punctuation\">\\</span>http</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name-definition class-name\">MyClass</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">#code...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p><strong>在同一个文件中定义多个命名空间：</strong> 在同一个文件中声明多个命名空间有两种方式，不过在实际编程实践中，非常不提倡在同一个文件中定义多戈命名空间。这种方式的主要用于将多个 PHP 脚本合并在同一个文件中。下面列出第一种方法。</p>\n<div class=\"remark-highlight\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token keyword\">namespace</span> <span class=\"token package\">MyProject<span class=\"token punctuation\">\\</span>helper<span class=\"token punctuation\">\\</span>http</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name-definition class-name\">MyClass</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">#code...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">namespace</span> <span class=\"token package\">MyProject<span class=\"token punctuation\">\\</span>helper<span class=\"token punctuation\">\\</span>request</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name-definition class-name\">MyClass</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">#code...</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>不过强烈不建议使用这种方法，可以参考下面的大括号定义法：</p>\n<div class=\"remark-highlight\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token keyword\">namespace</span> <span class=\"token package\">MyProject<span class=\"token punctuation\">\\</span>helper<span class=\"token punctuation\">\\</span>http</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name-definition class-name\">MyClass</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">#code...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">namespace</span> <span class=\"token package\">MyProject<span class=\"token punctuation\">\\</span>helper<span class=\"token punctuation\">\\</span>request</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name-definition class-name\">MyClass</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">#code...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h2 id=\"hash-PHP-命名空间中的元素使用\">PHP 命名空间中的元素使用</h2>\n<p>在讨论如何使用命名空间之前，必须了解 PHP 是如何知道要使用哪一个命名空间中的元素的。类名可以通过三种方式引用：</p>\n<ol>\n<li>非限定名称，或不包含前缀的类名称，例如 <code>$a=new foo();</code> 或 <code>foo::staticmethod();</code>。如果当前命名空间是 <code>currentnamespace</code>，<code>foo</code> 将被解析为 <code>currentnamespace\\foo</code>。如果使用 <code>foo</code> 的代码是全局的，不包含在任何命名空间中的代码，则 <code>foo</code> 会被解析为 <code>foo</code>。警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。详情参见 使用命名空间：后备全局函数名称/常量名称。</li>\n<li>限定名称,或包含前缀的名称，例如 <code>$a = new subnamespace\\foo()</code>; 或 <code>subnamespace\\foo::staticmethod()</code>;。如果当前的命名空间是 <code>currentnamespace</code>，则 <code>foo</code> 会被解析为 <code>currentnamespace\\subnamespace\\foo</code>。如果使用 <code>foo</code> <code>的代码是全局的，不包含在任何命名空间中的代码，foo</code> 会被解析为 <code>subnamespace\\foo</code>。</li>\n<li>完全限定名称，或包含了全局前缀操作符的名称，例如， <code>$a = new \\currentnamespace\\foo()</code>; 或 <code>\\currentnamespace\\foo::staticmethod()</code>;。在这种情况下，<code>foo</code> 总是被解析为代码中的文字名<code>(literal name)currentnamespace\\foo</code>。</li>\n</ol>\n<h2 id=\"hash-使用命名空间\">使用命名空间</h2>\n<p>允许通过别名引用或导入外部的完全限定名称，是命名空间的一个重要特征。PHP 命名空间支持 有两种使用别名或导入方式：为类名称使用别名，或为命名空间名称使用别名。在PHP中，别名是通过操作符 <code>use</code> 来实现的。</p>\n<p>注意PHP不支持导入函数或常量。</p>\n<div class=\"remark-highlight\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token keyword\">namespace</span> <span class=\"token package\">foo</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token package\">My<span class=\"token punctuation\">\\</span>Full<span class=\"token punctuation\">\\</span>Classname</span> <span class=\"token keyword\">as</span> Another<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 下面的例子与 use My\\Full\\NSname as NSname 相同</span>\n<span class=\"token keyword\">use</span> <span class=\"token package\">My<span class=\"token punctuation\">\\</span>Full<span class=\"token punctuation\">\\</span>NSname</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 导入一个全局类</span>\n<span class=\"token keyword\">use</span> <span class=\"token package\"><span class=\"token punctuation\">\\</span>ArrayObject</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<h2 id=\"hash-名称解析规则\">名称解析规则</h2>\n<p>在说明名称解析规则之前，我们先看一些重要的定义：</p>\n<ol>\n<li>非限定名称Unqualified name：名称中不包含命名空间分隔符的标识符，例如 Foo</li>\n<li>限定名称Qualified name：名称中含有命名空间分隔符的标识符，例如 Foo\\Bar</li>\n<li>完全限定名称Fully qualified name：名称中包含命名空间分隔符，并以命名空间分隔符开始的标识符，例如 \\Foo\\Bar。 namespace\\Foo 也是一个完全限定名称。</li>\n</ol>\n<p>名称解析遵循下列规则：</p>\n<ol>\n<li>对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \\A\\B 解析为类 A\\B。</li>\n<li>所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\\B\\C 被导入为 C，那么对 C\\D\\e() 的调用就会被转换为 A\\B\\C\\D\\e()。</li>\n<li>在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\\B 内部调用 C\\D\\e()，则 C\\D\\e() 会被转换为 A\\B\\C\\D\\e() 。</li>\n<li>非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\\B\\C 导入为C，则 new C() 被转换为 new A\\B\\C() 。</li>\n<li>在命名空间内部（例如A\\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：</li>\n</ol>\n<ol>\n<li>在当前命名空间中查找名为 A\\B\\foo() 的函数</li>\n<li>尝试查找并调用 全局(global) 空间中的函数 foo()。</li>\n</ol>\n<ol start=\"6\">\n<li>在命名空间（例如A\\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new C() 及 new D\\E() 的解析过程： new C()的解析:<br>\n在当前命名空间中查找A\\B\\C类。<br>\n尝试自动装载类A\\B\\C。</li>\n</ol>\n<p>new D\\E()的解析:<br>\n在类名称前面加上当前命名空间名称变成：A\\B\\D\\E，然后查找该类。<br>\n尝试自动装载类 A\\B\\D\\E。</p>\n<p>为了引用全局命名空间中的全局类，必须使用完全限定名称 new \\C()。</p>\n<h2 id=\"hash-Example-名称解析示例\">Example 名称解析示例</h2>\n<div class=\"remark-highlight\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token keyword\">namespace</span> <span class=\"token package\">A</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token package\">B<span class=\"token punctuation\">\\</span>D</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C</span>\\<span class=\"token constant\">E</span> <span class=\"token keyword\">as</span> <span class=\"token constant\">F</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 函数调用</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// 首先尝试调用定义在命名空间\"A\"中的函数foo()</span>\n            <span class=\"token comment\">// 再尝试调用全局函数 \"foo\"</span>\n\n<span class=\"token function\"><span class=\"token punctuation\">\\</span>foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 调用全局空间函数 \"foo\" </span>\n\n<span class=\"token function\">my<span class=\"token punctuation\">\\</span>foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 调用定义在命名空间\"A\\my\"中函数 \"foo\" </span>\n\n<span class=\"token function\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 首先尝试调用定义在命名空间\"A\"中的函数 \"F\" </span>\n            <span class=\"token comment\">// 再尝试调用全局函数 \"F\"</span>\n\n<span class=\"token comment\">// 类引用</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 创建命名空间 \"A\" 中定义的类 \"B\" 的一个对象</span>\n            <span class=\"token comment\">// 如果未找到，则尝试自动装载类 \"A\\B\"</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">D</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 使用导入规则，创建命名空间 \"B\" 中定义的类 \"D\" 的一个对象</span>\n            <span class=\"token comment\">// 如果未找到，则尝试自动装载类 \"B\\D\"</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 使用导入规则，创建命名空间 \"C\" 中定义的类 \"E\" 的一个对象</span>\n            <span class=\"token comment\">// 如果未找到，则尝试自动装载类 \"C\\E\"</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name class-name-fully-qualified\"><span class=\"token punctuation\">\\</span>B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 创建定义在全局空间中的类 \"B\" 的一个对象</span>\n            <span class=\"token comment\">// 如果未发现，则尝试自动装载类 \"B\"</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name class-name-fully-qualified\"><span class=\"token punctuation\">\\</span>D</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 创建定义在全局空间中的类 \"D\" 的一个对象</span>\n            <span class=\"token comment\">// 如果未发现，则尝试自动装载类 \"D\"</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name class-name-fully-qualified\"><span class=\"token punctuation\">\\</span>F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 创建定义在全局空间中的类 \"F\" 的一个对象</span>\n            <span class=\"token comment\">// 如果未发现，则尝试自动装载类 \"F\"</span>\n\n<span class=\"token comment\">// 调用另一个命名空间中的静态方法或命名空间函数</span>\n\n<span class=\"token constant\">B</span><span class=\"token function\"><span class=\"token punctuation\">\\</span>foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 调用命名空间 \"A\\B\" 中函数 \"foo\"</span>\n\n<span class=\"token scope\">B<span class=\"token punctuation\">::</span></span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 调用命名空间 \"A\" 中定义的类 \"B\" 的 \"foo\" 方法</span>\n            <span class=\"token comment\">// 如果未找到类 \"A\\B\" ，则尝试自动装载类 \"A\\B\"</span>\n\n<span class=\"token scope\">D<span class=\"token punctuation\">::</span></span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 使用导入规则，调用命名空间 \"B\" 中定义的类 \"D\" 的 \"foo\" 方法</span>\n            <span class=\"token comment\">// 如果类 \"B\\D\" 未找到，则尝试自动装载类 \"B\\D\"</span>\n\n\\<span class=\"token constant\">B</span><span class=\"token function\"><span class=\"token punctuation\">\\</span>foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 调用命名空间 \"B\" 中的函数 \"foo\" </span>\n\n<span class=\"token class-name class-name-fully-qualified static-context\"><span class=\"token punctuation\">\\</span>B</span><span class=\"token operator\">::</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 调用全局空间中的类 \"B\" 的 \"foo\" 方法</span>\n            <span class=\"token comment\">// 如果类 \"B\" 未找到，则尝试自动装载类 \"B\"</span>\n\n<span class=\"token comment\">// 当前命名空间中的静态方法或函数</span>\n\n<span class=\"token scope\">A<span class=\"token punctuation\">\\</span>B<span class=\"token punctuation\">::</span></span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 调用命名空间 \"A\\A\" 中定义的类 \"B\" 的 \"foo\" 方法</span>\n              <span class=\"token comment\">// 如果类 \"A\\A\\B\" 未找到，则尝试自动装载类 \"A\\A\\B\"</span>\n\n<span class=\"token class-name class-name-fully-qualified static-context\"><span class=\"token punctuation\">\\</span>A<span class=\"token punctuation\">\\</span>B</span><span class=\"token operator\">::</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 调用命名空间 \"A\\B\" 中定义的类 \"B\" 的 \"foo\" 方法</span>\n              <span class=\"token comment\">// 如果类 \"A\\B\" 未找到，则尝试自动装载类 \"A\\B\"</span>\n</code></pre></div>\n","words":3820,"toc":[{"depth":2,"value":"命名空间概述","id":"hash-命名空间概述"},{"depth":2,"value":"定义命名空间","id":"hash-定义命名空间"},{"depth":2,"value":"PHP 命名空间中的元素使用","id":"hash-PHP-命名空间中的元素使用"},{"depth":2,"value":"使用命名空间","id":"hash-使用命名空间"},{"depth":2,"value":"名称解析规则","id":"hash-名称解析规则"},{"depth":2,"value":"Example 名称解析示例","id":"hash-Example-名称解析示例"}],"title":"PHP 面向对象编程和设计模式 (5/5) - PHP 命名空间的使用及名称解析规则","author":"高国良","type":"posts","series":false,"date":"2014-06-12T10:23:00.791Z","tags":["php","namespace"],"description":"PHP 在 5.3.0 以后的版本开始支持命名空间。什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题","draft":false,"cover":false},"prev":{"title":"PHP 面向对象编程和设计模式 (4/5) - 异常的定义、扩展及捕获","author":"高国良","type":"posts","series":false,"date":1402536000791,"tags":["php","Exception"],"description":"PHP5 增加了类似其他语言的异常处理模块。在PHP代码中所产生的异常可被 throw 语句抛出并被 catch 语句捕获。需要进行异常处理的代码都必须放入到 try 代码块内，以便捕获可能存在的异常。每个try至少对应一个 catch 块。使用多个 catch 可以捕获不同的类所产生的异常。","draft":false,"cover":false,"path":"/blogs/2014/php-oop-and-design-pattern-4-exception","slug":"2014/php-oop-and-design-pattern-4-exception"},"next":{"title":"PHP 高级编程(1/5) - 编码规范及文档编写","author":"高国良","type":"posts","series":false,"date":1402621380791,"tags":["php","PHPDoc"],"description":"软件开发中的一个重要环节就是文档编写。他可以帮助未来的程序维护人员和使用者理解你在开发时的思路。也便于日后重新查看代码时不至于无从下手。文档还有一个重要的作用，在不用了解要访问对象的细节情况下也能很好的在对象之间进行交互。文档的编写有一些成熟的行业标准格式，遵守这些行业标准将有助于创建易于阅读的代表，并使自动生成手册成为可能。","draft":false,"cover":false,"path":"/blogs/2014/php-advanced-programming-1-coding-specification-and-documentation","slug":"2014/php-advanced-programming-1-coding-specification-and-documentation"}},"__N_SSG":true}