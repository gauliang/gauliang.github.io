{"pageProps":{"post":{"id":["2020","block-formatting-context"],"contentHtml":"<p>了解 BFC 是什么，它具备什么布局特性，以及如何创建 BFC，有助于深入理解 CSS 布局的工作方式。</p>\n<h2 id=\"hash-什么是-BFC\">什么是 BFC</h2>\n<p><strong>块格式化上下文(Block Formatting Context)</strong> 是一个独立的渲染区域，它指定内部 <code>Block-level Box</code> 的布局方式，并且与该区域的外部无关（无论内部元素如何排列，都不会影响外部元素）。</p>\n<h2 id=\"hash-BFC-布局规则\">BFC 布局规则</h2>\n<ol>\n<li>在块格式设置上下文中的盒子从其顶部开始垂直地一个接一个地布局。</li>\n<li>两个兄弟盒子之间的垂直距离由'margin'属性确定。块格式化上下文中相邻块级框之间的垂直边距将会叠加，最终结果由较大的外边距决定。\n<ol>\n<li>在块格式上下文中的所有盒子都是左对齐（用于从左到右格式）的，并且它们的左外边缘接触包含块的左边缘，即便存在浮动盒子也是如此，除非创建了新的跨格式化上下文。\n<ol>\n<li>在块格式设置上下文中的盒子从其顶部开始垂直地一个接一个地布局。</li>\n</ol>\n</li>\n<li>两个兄弟盒子之间的垂直距离由'margin'属性确定。块格式化上下文中相邻块级框之间的垂直边距将会叠加，最终结果由较大的外边距决定。</li>\n<li>在块格式上下文中的所有盒子都是左对齐（用于从左到右格式）的，并且它们的左外边缘接触包含块的左边缘，即便存在浮动盒子也是如此，除非创建了新的跨格式化上下文。\n<ul>\n<li>在块格式设置上下文中的盒子从其顶部开始垂直地一个接一个地布局。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>两个兄弟盒子之间的垂直距离由'margin'属性确定。块格式化上下文中相邻块级框之间的垂直边距将会叠加，最终结果由较大的外边距决定。</li>\n<li>在块格式上下文中的所有盒子都是左对齐（用于从左到右格式）的，并且它们的左外边缘接触包含块的左边缘，即便存在浮动盒子也是如此，除非创建了新的跨格式化上下文。</li>\n<li>在块格式设置上下文中的盒子从其顶部开始垂直地一个接一个地布局。</li>\n<li>两个兄弟盒子之间的垂直距离由'margin'属性确定。块格式化上下文中相邻块级框之间的垂直边距将会叠加，最终结果由较大的外边距决定。</li>\n<li>在块格式上下文中的所有盒子都是左对齐（用于从左到右格式）的，并且它们的左外边缘接触包含块的左边缘，即便存在浮动盒子也是如此，除非创建了新的跨格式化上下文。</li>\n<li>在块格式设置上下文中的盒子从其顶部开始垂直地一个接一个地布局。</li>\n<li>两个兄弟盒子之间的垂直距离由'margin'属性确定。块格式化上下文中相邻块级框之间的垂直边距将会叠加，最终结果由较大的外边距决定。</li>\n<li>在块格式上下文中的所有盒子都是左对齐（用于从左到右格式）的，并且它们的左外边缘接触包含块的左边缘，即便存在浮动盒子也是如此，除非创建了新的跨格式化上下文。</li>\n</ol>\n<div class=\"image-widget\"><img src=\"/posts/2020/block-formatting-context.files/001.jpg\" alt=\"Block Formatting Context\"><div class=\"figcaption\">Block Formatting Context</div></div>\n<p>如上图中所看到的，属于块格式上下文的所有盒子都左对齐（对于LTR），并且它们的左外边缘接触包含块的左边缘。在最后一个框中，我们可以看到，即使左侧有一个浮动的元素（棕色），另一个元素（绿色）仍会触及包含块的左侧边距。</p>\n<h2 id=\"hash-如何创建-BFC\">如何创建 BFC</h2>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>\n</blockquote>\n<p>让我们以一种更易于理解的方式重新定义它。满足以下条件之一即可出发块格式化上下文：</p>\n<ul>\n<li><code>float</code> 属性不为 <code>none</code></li>\n<li><code>position</code> 属性不为 <code>static</code> 或 <code>relative</code></li>\n<li><code>display</code> 属性取值 <code>table-cell</code>，<code>table-caption</code>，<code>inline-block</code>，<code>flex</code> 或 <code>inline-flex</code></li>\n<li><code>overflow</code> 属性取值不为 <code>visible</code></li>\n</ul>\n<p>明确触发块格式化上下文条件后，如果我们想创建一个新的块格式上下文，只需要向其添加任何上述 CSS 条件即可。\n尽管上述任何条件都可以创建块格式化上下文，但是也可能为你的布局带来一些副作用，例如：</p>\n<ul>\n<li><code>display: table</code> 可能会在响应能力方面造成问题</li>\n<li><code>overflow: scroll</code> 可能显示不需要的滚动条</li>\n<li><code>float: left</code> 将元素推向左侧，其他元素环绕</li>\n<li><code>overflow: hidden</code> 将剪辑溢出的元素</li>\n</ul>\n<p>因此，无论何时创建新的块格式化上下文，都需在不造成副作用的前提下做出最佳选择。</p>\n<h2 id=\"hash-使用-BFC\">使用 BFC</h2>\n<p>这里仅举例两个利用 BFC 特性的小用例。</p>\n<p>利用其包含浮动元素的特性，可用来避免父元素内的浮动子元素逃逸。</p>\n<p><figure class=\"codepen-widget\"><iframe \n                height='500' \n                scrolling='no' \n                src='//codepen.io/gauliang/embed/preview/RwRPovR/?height=500&theme-id=dark&default-tab=result' \n                frameborder='no' \n                title='codepen embed'\n                allowtransparency='true' \n                allowfullscreen='true' \n                style='width: 100%;'></iframe></figure></p>\n<p>根据<a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://www.w3.org/TR/CSS2/box.html#collapsing-margins\">外边距合并原则</a>，利用块格式上下文避免父子元素外边距合并。</p>\n<p><figure class=\"codepen-widget\"><iframe \n                height='500' \n                scrolling='no' \n                src='//codepen.io/gauliang/embed/preview/NWrqbbd/?height=500&theme-id=dark&default-tab=result' \n                frameborder='no' \n                title='codepen embed'\n                allowtransparency='true' \n                allowfullscreen='true' \n                style='width: 100%;'></iframe></figure></p>\n<h2 id=\"hash-参考\">参考</h2>\n<ol>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\">https://www.w3.org/TR/CSS2/visuren.html#block-formatting</a></li>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/\">https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/</a></li>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://www.smashingmagazine.com/2017/12/understanding-css-layout-block-formatting-context/\">Understanding Block Formatting Contexts in CSS</a></li>\n</ol>\n","toc":[{"depth":2,"value":"什么是 BFC","id":"hash-什么是-BFC"},{"depth":2,"value":"BFC 布局规则","id":"hash-BFC-布局规则"},{"depth":2,"value":"如何创建 BFC","id":"hash-如何创建-BFC"},{"depth":2,"value":"使用 BFC","id":"hash-使用-BFC"},{"depth":2,"value":"参考","id":"hash-参考"}],"title":"Block Formatting Context","date":"2020-10-10T09:03:29.000Z","draft":false,"description":"块格式化上下文(Block Formatting Context) 是一个独立的渲染区域，它指定内部 `Block-level Box` 的布局方式，并且与该区域的外部无关（无论内部元素如何排列，都不会影响外部元素）。","type":"posts","tags":["BFC","CSS","layout"],"series":[],"author":"Gl","cover":"css.jpg"},"prev":{"title":"Javascript Promise","date":1599998424000,"draft":false,"description":"Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。","type":"posts","tags":["javascript","node.js","promise"],"series":[],"author":"Gl","cover":"001.jpg","slug":"2020/promise"},"next":{"title":"Javascript Closure","date":1602413155000,"draft":false,"description":"函数和与其相关的词法环境（lexical environment）一起构成闭包（closure）。闭包可以让你从内部函数访问外部函数作用域，在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。","type":"posts","tags":["closure","lexical-environment","javascript","node.js","闭包"],"series":[],"author":"Gl","cover":"cover.jpg","slug":"2020/javascript-closure"}},"__N_SSG":true}