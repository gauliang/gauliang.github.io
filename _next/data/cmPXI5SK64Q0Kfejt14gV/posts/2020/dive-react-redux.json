{"pageProps":{"post":{"id":["2020","dive-react-redux"],"contentHtml":"<div class=\"image-widget\"><img src=\"/posts/2020/dive-react-redux.files/dive-react-redux.jpg\" alt=\"深入 Redux\"><div class=\"figcaption\">深入 Redux</div></div>\n<h2 id=\"hash-Flux-模型\">Flux 模型</h2>\n<p>Flux 是 Facebook 用于构建客户端 Web 应用程序的<strong>应用程序体系结构</strong>，它更像是一种模式，而不是正式的框架。\nFlux 模型包含三个主要部分：Dispatcher，Store 和 View(React组件)。Flux 避免使用 MVC 来支持单向数据流。\n当用户与 View 进行交互时，View 通过 Dispatcher 将 Action 分发到保存应用程序数据和业务逻辑的 Store，然后再更新受影响的 View。\n在外部不能直接修改 Store 的数据，必须通过 Dispather 传递 Action 给 Store 中注册的回调函数来实现数据修改，这有助于将关注点清晰的分开。</p>\n<div class=\"image-widget\"><img src=\"/posts/2020/dive-react-redux.files/flux-simple.png\" alt=\"单向数据流是 Flux 模式的核心\"><div class=\"figcaption\">单向数据流是 Flux 模式的核心</div></div>\n<p>Flux 应用程序的数据沿单一方向流动，上图中 Dispatcher、Store、View 是具有独立输入输出的节点，Action 是一个简单对象，包含新数据和标识 Action 类型的 type 属性。\n用户与 View 的交互会在系统中产生 Action 传播。</p>\n<ol>\n<li>所有数据都流经 Dispatcher，提供给 Dispatcher 的 Action 是通过 <em>Action creator</em> 方法创建的对象，这通常来自用户与视图的交互。</li>\n<li>Dispatcher 通过调用注册在 Store 中的回调函数完成 Action 到 Store 的分发。在已注册的回调中，Store 将响应与其所维护状态相关的具体操作。</li>\n<li>Store 触发 <code>change</code> 事件，将数据层的变化通知到 Controller-views。</li>\n<li>Controller-views 监听这些事件，并从  event handler 中读取来自 Stores 的数据。</li>\n<li>Controller-views 调用他们自己的 <code>setState()</code> 方法，从而在组件树中更新自身及其所有后代。</li>\n</ol>\n<p>这与双向数据绑定有着显著不同，应用程序状态仅在 Store 中维护，从而使应用程序的不同部分保持高度分离。单项数据流，也使整个系统变得更加可预测。\n双向数据绑定会导致级联更新，其中更改一个对象会导致另一个对象更改，这也可能触发更多更新。随着应用程序的增长，这些级联更新使得由用户交互而发生的变化很难预测。</p>\n<h3 id=\"hash-1-1-Dispatcher\">1.1 Dispatcher</h3>\n<p>Dispatcher 是 Flux 应用程序的中央调度器，能够分发 Action 到 Store 中。它维护一个 callback 注册表，这些回调函数(callback)能够与 Store 进行交互。\n每个 Store 都在 Dispatcher 中注册自己并提供回调函数，当 <strong>Action creator</strong> 提供一个新的 Action 给 Dispatcher 时，Store 可以通过注册到注册表中的 callback 接收 Action。</p>\n<p>随着应用程序的增长，Dispatcher 会变得越来越重要，它还可以通过按特定顺序调用注册的 callback 来管理 Store 之间的依赖关系。\nStore 也可以声明性地等待其它 Store 完成更新，然后再进行相应的更新。</p>\n<h3 id=\"hash-1-2-Store\">1.2 Store</h3>\n<p>Store 存储应用程序状态和逻辑。如上所述，Store 在 Dispatcher 中注册自己，并为其提供 callback。该 callback 将 Action 作为参数接收，callback 内部基于 Action type 的 switch\n语句为不同类型的 Action 执行不同的操作，这使得 Action 能够通过 Dispatcher 更新存储在 Store 中的数据。Store 更新后，它会广播一个事件，声明其状态已经更改，视图可以查询新状态并完成更新。</p>\n<h3 id=\"hash-1-3-Controller-view\">1.3 Controller-view</h3>\n<p>React 提供了视图的嵌套能力，在嵌套视图层次的顶部，我们可以通过一个特殊视图订阅 Store 的广播事件，我们称这样的视图组件为控制器视图(Controller-view)，\n它能够从 Store 中获取数据，并向下传递至其后代链。当从视图接收到事件时，可通过 Store 的 <code>getter</code> 方法请求所需数据，\n然后，调用 <code>setState()</code> 或 <code>forceUpdate()</code> 方法促使自己和后代的 <code>render()</code> 方法运行。</p>\n<h3 id=\"hash-1-4-Action\">1.4 Action</h3>\n<p>Action 是一个简单的 js 对象，用以描述 Flux 模型中的动作，其结构为 <code>{type:'type',payload:'data'}</code>。可以将其发送给 Dispatcher 公开的方法，以实现 Action 到 Store 派发。</p>\n<h2 id=\"hash-Redux-模型\">Redux 模型</h2>\n<p>由于 Flux 本身并不是框架，因此开发人员已尝试提出 Flux 模式的许多实现。最终，一个明显的赢家出现了，那就是 Redux，其已成为 React 生态中开发人员集中管理应用状态的事实标准库。</p>\n<p>Redux 是一个面向 JS 应用程序的可预测状态管理器，它使用基于 <strong>Action</strong> 的事件模型来管理和更新应用程序状态，从而现集中化管理应用程序状态和逻辑。\n作为一个通用解决方案，Redux 可与任何 UI 层一起使用，如 React、Angular、Vue 等。虽然 Redux 是 Flux 架构的实现，但也存在一些细微差异。</p>\n<h3 id=\"hash-2-1-Actions\">2.1 Actions</h3>\n<p>这与 Flux 中的定义相同，Action 是一个 JS 简单对象，包含 <code>type</code> 字段及一些可选的载荷信息。可以把 Action 理解为描述应用中事件的描述。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> addTodoAction <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'todos/todoAdded'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">payload</span><span class=\"token operator\">:</span> <span class=\"token string\">'Buy milk'</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h3 id=\"hash-2-2-Action-Creators\">2.2 Action Creators</h3>\n<p><strong>Action Creator</strong> 是一个创建并返回 Action 对象的方法，通过它可以避免在每次使用 Action 时书写重复的代码。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">addTodo</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">text</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword control-flow\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'todos/todoAdded'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">payload</span><span class=\"token operator\">:</span> text\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h3 id=\"hash-2-3-Reducers\">2.3 Reducers</h3>\n<p>Reducer 是一个函数，它接收两个参数，分别为当前 <code>state</code> 和 <code>action</code> 对象，Reducer 内部决定如何更新 state，并返回一个新的 state。可以描述为 <code>(state, action) => newState</code>。\n可以把 Reducer 视为事件侦听器，该事件侦听器根据接收到的 action(event) 来处理事件。Reducer 必须遵循下列规则：</p>\n<ol>\n<li>通过 <code>state</code> 和 <code>action</code> 参数计算并返回 <strong>全新的</strong> <code>state</code>；</li>\n<li>不能修改已经存在的 <code>state</code>，内部可以通过拷贝已经存在的 <code>state</code> 进行相关操作；</li>\n<li>不能具有副作用(side effects)。如果用同样的参数两次调用必须返回可预期的结果，内部不能出现如异步或 random 之类的操作；</li>\n</ol>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> initialState <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">value</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">counterReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">state <span class=\"token operator\">=</span> initialState<span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword control-flow\">if</span> <span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">.</span><span class=\"token property-access\">type</span> <span class=\"token operator\">===</span> <span class=\"token string\">'counter/increment'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword control-flow\">return</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token spread operator\">...</span>state<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">value</span><span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span><span class=\"token property-access\">value</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword control-flow\">return</span> state\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>Reducer 内部可以通过 <code>if/else</code> 或 <code>switch</code> 等语句，根据不同的 <code>action.type</code> 作出不同的响应并返回新的 <code>state</code>。</p>\n<h3 id=\"hash-2-4-Store\">2.4 Store</h3>\n<p>Redux 应用的当前 <code>state</code> 保存在一个称为 <strong>Store</strong> 的对象上，<strong>Store</strong> 对象通过传入 Reducer 创建，并对外提供 <code>getState</code> 方法，该方法返回当前 <code>state</code> 信息。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token function\">createStore</span><span class=\"token punctuation\">(</span>counterReducer<span class=\"token punctuation\">)</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\">// {value: 0}</span>\n\n</code></pre></div>\n<h3 id=\"hash-2-5-Dispatch\">2.5 Dispatch</h3>\n<p>Redux Store 对象还拥有一个名为 <code>dispatch</code> 的方法，更新 <code>state</code> 的唯一方法就是传递一个 <code>action</code> 对象给该方法。Store 内部会执行 reducer 方法，并保存一份新数据。\n当我们再次调用 <code>getState()</code> 将会返回更新过的 <code>state</code>。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'counter/increment'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>store<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\">// {value: 1}</span>\n</code></pre></div>\n<p>您可以将 Dispatch 视为 <strong>触发事件</strong>，通过 Dispatch 通知 Store 应用中存在 Action 需要处理，Reducer 的行为就像事件侦听器，当他们接收到自己感兴趣的 Action 时，会响应事件并更新状态。</p>\n<h3 id=\"hash-2-6-Selector\">2.6 Selector</h3>\n<p>Selector 是可以从 Store State 中提取特定信息的函数。当应用程序变得庞大时，它将变得很有用。</p>\n<h2 id=\"hash-Redux-数据流\">Redux 数据流</h2>\n<ol>\n<li>初始化\n<ol>\n<li>使用 <strong>root reducer</strong> 创建 <strong>Redux store</strong>;</li>\n<li><strong>Store</strong> 调用 <code>reducer</code> 并保存其初始值；</li>\n<li>当 View 第一次被渲染，会从 Redux store 中访问当前 <code>state</code> 并根据 <code>state</code> 渲染视图。View 也可以订阅 Store 的变更消息，这样在未来当 state 再次变化，视图就能够发现并处理它。</li>\n</ol>\n</li>\n<li>更新数据\n<ol>\n<li>当一些事情在应用中发生，如用户点击了某个按钮，会创建 Action；</li>\n<li>分发 Action 到 Redux Store，代码类似 <code>dispatch({type:\"counter/increment\"})</code>;</li>\n<li>Store 再次执行 reducer 函数，通过之前的 <code>state</code> 和 <code>action</code> 完成计算、存储并返回新的 <code>state</code>；</li>\n<li>Store 通知所有订阅了 Store 数据变更消息的 View 组件；</li>\n<li>每个依赖 <code>state</code> 数据的 View 组件都会对 <code>state</code> 数据进行检查，以确定是否需要重新渲染自己；</li>\n<li>需要重新渲染的组件使用新数据完成渲染。</li>\n</ol>\n</li>\n</ol>\n<div class=\"image-widget\"><img src=\"/posts/2020/dive-react-redux.files/ReduxDataFlowDiagram.gif\" alt=\"\"></div>\n<h2 id=\"hash-React-redux\">React-redux</h2>\n<p>Redux 本身是一个独立的库，可与任何 UI 层或框架一起使用，通常需要使用 <strong>UI 绑定库</strong> 将 Redux 与 UI 框架绑定在一起，而不是通过 UI 代码直接与 <strong>Store</strong> 进行交互。\nReact Redux 是 React 的官方 Redux UI 绑定库，它使得 React 组件可以从 Redux store 读取数据或分发 <code>action</code> 到 <strong>Store</strong> 以更新 <code>state</code>。</p>\n<h3 id=\"hash-5-1-Provider\">5.1 Provider</h3>\n<p>React Redux 提供了一个 <code>&#x3C;Provider /></code> 组件，将 <strong>store</strong> 对象以 props 形式注入到组件中，可以使其所有子组件中均可访问到 store 对象。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword module\">import</span> <span class=\"token imports\"><span class=\"token maybe-class-name\">React</span></span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'react'</span>\n<span class=\"token keyword module\">import</span> <span class=\"token imports\"><span class=\"token maybe-class-name\">ReactDOM</span></span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'react-dom'</span>\n\n<span class=\"token keyword module\">import</span> <span class=\"token imports\"><span class=\"token punctuation\">{</span> <span class=\"token maybe-class-name\">Provider</span> <span class=\"token punctuation\">}</span></span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'react-redux'</span>\n<span class=\"token keyword module\">import</span> <span class=\"token imports\">store</span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'./store'</span>\n\n<span class=\"token keyword module\">import</span> <span class=\"token imports\"><span class=\"token maybe-class-name\">App</span></span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'./App'</span>\n\n<span class=\"token keyword\">const</span> rootElement <span class=\"token operator\">=</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\n<span class=\"token maybe-class-name\">ReactDOM</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&#x3C;</span><span class=\"token maybe-class-name\">Provider</span> store<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>store<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&#x3C;</span><span class=\"token maybe-class-name\">App</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&#x3C;</span><span class=\"token operator\">/</span><span class=\"token maybe-class-name\">Provider</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  rootElement\n<span class=\"token punctuation\">)</span>\n</code></pre></div>\n<h3 id=\"hash-5-2-Connect\">5.2 Connect</h3>\n<p>React Redux 通过名为 <code>connect</code> 的函数将组件和 <strong>store</strong> 对象进行链接，随后在组件内部能以 props 的形式访问 <code>dispatch</code> 和 <code>state</code>。</p>\n<div class=\"remark-highlight\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword module\">import</span> <span class=\"token imports\"><span class=\"token punctuation\">{</span> connect <span class=\"token punctuation\">}</span></span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'react-redux'</span>\n<span class=\"token keyword module\">import</span> <span class=\"token imports\"><span class=\"token punctuation\">{</span> increment<span class=\"token punctuation\">,</span> decrement<span class=\"token punctuation\">,</span> reset <span class=\"token punctuation\">}</span></span> <span class=\"token keyword module\">from</span> <span class=\"token string\">'./actionCreators'</span>\n\n<span class=\"token keyword\">const</span> mapStateToProps <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>state <span class=\"token comment\">/*, ownProps*/</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword control-flow\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">counter</span><span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span><span class=\"token property-access\">counter</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> mapDispatchToProps <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> increment<span class=\"token punctuation\">,</span> decrement<span class=\"token punctuation\">,</span> reset <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword module\">export</span> <span class=\"token keyword module\">default</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>\n  mapStateToProps<span class=\"token punctuation\">,</span>\n  mapDispatchToProps\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token maybe-class-name\">Counter</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<h2 id=\"hash-Redux-Toolkit\">Redux Toolkit</h2>\n<p>Redux Toolkit 通过遵循 Redux 最佳实践，提供了良好的默认行为，捕获错误并允许您编写更简单的代码，使编写良好的 Redux 应用程序和加快开发速度变得更加容易。</p>\n<p>Redux Toolkit 提供了一系列实用功能，包括：</p>\n<ol>\n<li><code>configureStore()</code> —— 简化创建 Store 配置选项。它可以自动组合 Reducer slice，并加载常用中间件，如 <code>redux-thunk</code>，并默认启用哪个 <strong>Redux DevTools Extension</strong>；</li>\n<li><code>createReducer()</code> —— 内部自动使用 <code>immer</code> 简化了数据更新；</li>\n<li><code>createAction()</code> —— 为给定动作类型字符串创建 <strong>action creator</strong> 函数。</li>\n<li><code>createSlice</code> —— 接受一组配置信息，如 name、initialState。自动生成 action coretor；</li>\n<li><code>createSelector</code> —— 更加便捷的从 state 中导出需要的数据</li>\n</ol>\n<p>Redux Toolkit 不仅简化了很多操作流程，还提供了一系列 Hook，使得在 React 组件中与 Redux Store 交互变轻而易举。</p>\n<h2 id=\"hash-参考\">参考</h2>\n<ul>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://redux.js.org\">https://redux.js.org</a></li>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://react-redux.js.org\">https://react-redux.js.org</a></li>\n<li><a target=\"_blank\" target=\"_blank\" class=\"ext-link\" href=\"https://facebook.github.io/flux/\">https://facebook.github.io/flux/</a></li>\n</ul>\n","toc":[{"depth":2,"value":"Flux 模型","id":"hash-Flux-模型"},{"depth":2,"value":"Redux 模型","id":"hash-Redux-模型"},{"depth":2,"value":"Redux 数据流","id":"hash-Redux-数据流"},{"depth":2,"value":"React-redux","id":"hash-React-redux"},{"depth":2,"value":"Redux Toolkit","id":"hash-Redux-Toolkit"},{"depth":2,"value":"参考","id":"hash-参考"}],"title":"深入 React Redux","date":"2020-11-15T00:24:14.000Z","draft":false,"description":"React Redux是React的官方Redux UI绑定库 。 如果您同时使用Redux和React，则还应该使用React Redux绑定这两个库。","type":"posts","tags":["react","redux","flux","javascript","node.js","redux-toolkit"],"series":["react"],"author":"Gl","cover":"dive-react-redux.jpg"},"prev":{"title":"深入 Webpack","date":1604536490000,"draft":false,"description":"大多数情况下，网站不再只是用带有一些可选 JavaScript 的纯 HTML 编写，它们通常完全由 JavaScript 构建。因此，我们必须将代码打包，最小化和翻译成所有浏览器都能理解的东西，这就是webpack的用武之地。","type":"posts","tags":["webpack","devops","node.js","esm"],"series":["Dive into webpack"],"author":"Gl","cover":"webpack.jpg","slug":"2020/dive-into-webpack"},"next":{"title":"Throttling and Debounce","date":1606385732000,"draft":false,"description":"节流是指，确保连续发生的事件（函数调用）按指定频率（时间间隔）触发执行器。防抖是指，事件发生（函数调用）后，在指定时间内，同样的操作只有最后一次会生效。","type":"posts","tags":["debounce","throttle","javascript"],"series":[],"author":"Gl","cover":"throttle-and-debounce.jpg","slug":"2020/throttle-and-debounce"}},"__N_SSG":true}